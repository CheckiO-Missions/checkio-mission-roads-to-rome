
<body data-author="freeman_lex">
<div class="question-answer">
    <div class="question">
        Je n'ai aucune id√©e de la mani√®re de commencer √† r√©soudre cette mission.
    </div>
    <div class="answer">
        <p>
            Attrapez la premi√®re id√©eüí°! Cette variante contrainte du probl√®me combinatoire classique s'av√®re avoir une solution r√©cursive raisonnablement simple. Dans le cas de base, le nombre de chemins de l'origine <b>(0, 0)</b> √† elle-m√™me est √©gal √† un pour le chemin vide (notez la diff√©rence cruciale entre un chemin vide qui existe, et un chemin inexistant!). Si le point <b>(x, y)</b> figure dans la liste <b>tabu</b>, le nombre de chemins de ce point √† l'origine est √©gal √† z√©ro. Sinon, le nombre de chemins du point √† l'origine est √©gal √† la somme des chemins des deux voisins (x-1, y) et (x, y-1). Cependant, cette simple r√©cursion se ramifie en un nombre exponentiel de possibilit√©s et peut donc √™tre beaucoup trop lente √† ex√©cuter. Par cons√©quent, vous devriez soit m√©moriser la r√©cursion √† l'aide de <b>lru_cache</b>, ou mieux encore...
        </p>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Cette voie est difficile pour moi. Avez-vous une autre id√©e?
    </div>
    <div class="answer">
        <p>
            Oui, en voici une autre. N'utilisez pas du tout la r√©cursivit√©, mais construisez une liste √† deux dimensions dont les entr√©es sont les solutions individuelles des sous-probl√®mes. Remplissez les valeurs correctes avec deux boucles for dans un ordre qui garantit que lorsque ces boucles arrivent √† la position [x][y], les r√©sultats pour les positions [x-1][y] et [x][y-1] n√©cessaires pour calculer [x][y] s'y trouvent d√©j√†.
        </p>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Je vous remercie! J'en sais plus et je comprends mieux maintenant! Tout fonctionne bien!
    </div>
    <div class="answer">
        Heureux de l'apprendre üëç!
    </div>
</div>
</body>